/*
 * Copyright (c) 2012-2013, Centre National de la Recherche Scientifique.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -----
 * 
 * Implemented by Etienne Duble (CNRS / LIG).
 * A part of this work was done for the ANR ARESA2 project.
 * 
 * This file is part of a generic sniffer implementation for contiki.
 * See Readme.txt for more details.
 * 
 * This tool reads packets encoded with the SLIP protocol from its standard
 * input, and write them in a PCAP format to its output.
 * It was partially based on http://freaklabs.org/index.php/WSBridge.html
 * and on the code specified in RFC 1055 (SLIP protocol).
 */
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>

#define MAX_PACKET_SIZE         65535
#define PACKET_FCS      2

#define END             0300    /* indicates end of packet */
#define ESC             0333    /* indicates byte stuffing */
#define ESC_END         0334    /* ESC ESC_END means END data byte */
#define ESC_ESC         0335    /* ESC ESC_ESC means ESC data byte */

#define DLT_IEEE802_15_4_LINUX		191
#define DLT_IEEE802_15_4		195
#define DLT_IEEE802_15_4_NONASK_PHY	215
#define DLT_IEEE802_15_4_NO_FCS		230

#ifdef SNIFFER_FRAMES_HAVE_FCS
#define DLT 		DLT_IEEE802_15_4
#else
#define DLT 		DLT_IEEE802_15_4_NO_FCS
#endif


static uint8_t packet[MAX_PACKET_SIZE];


int recv_packet() {
   int c;
   int received = 0;

   /* sit in a loop reading bytes until we put together
    * a whole packet.
    * Make sure not to copy them into the packet if we
    * run out of room.
    */
   while(1) {
	   /* get a character to process
	    */
	   c = getchar();

	   /* handle bytestuffing if necessary
	    */
	   switch(c) {

	   /* if it's an END character then we're done with
	    * the packet
	    */
	   case END:
		   /* a minor optimization: if there is no
		    * data in the packet, ignore it. This is
		    * meant to avoid bothering IP with all
		    * the empty packets generated by the
		    * duplicate END characters which are in
		    * turn sent to try to detect line noise.
		    */
		   if(received)
			   return received;
		   else
			   break;

	   /* if it's the same code as an ESC character, wait
	    * and get another character and then figure out
	    * what to store in the packet based on that.
	    */
	   case ESC:
		   c = getchar();

		   /* if "c" is not one of these two, then we
		    * have a protocol violation.  The best bet
		    * seems to be to leave the byte alone and
		    * just stuff it into the packet
		    */
		   switch(c) {
		   case ESC_END:
			   c = END;
			   break;
		   case ESC_ESC:
			   c = ESC;
			   break;
			   }

	   /* here we fall into the default handler and let
	    * it store the character for us
	    */
	   default:
		   if(received < MAX_PACKET_SIZE)
			   packet[received++] = c;
	   }
   }
}

/**************************************************************************/
/*!
    Write the global header to wireshark. This is only done once at the
    beginning of the capture. 
*/
/**************************************************************************/
static void write_global_pcap_hdr()
{
    uint32_t magic_number = 0xa1b2c3d4; /* magic number */
    uint16_t version_major = 2; /* major version number */
    uint16_t version_minor = 4; /* minor version number */
    int32_t thiszone = 0;       /* GMT to local correction */
    uint32_t sigfigs = 0;       /* accuracy of timestamps */
    uint32_t snaplen = MAX_PACKET_SIZE;   /* max length of captured packets, in octets */
    uint32_t network = DLT;  	/* data link type */

    write(1 /*stdout*/, &magic_number, sizeof(magic_number));
    write(1 /*stdout*/, &version_major, sizeof(version_major));
    write(1 /*stdout*/, &version_minor, sizeof(version_minor));
    write(1 /*stdout*/, &thiszone, sizeof(thiszone));
    write(1 /*stdout*/, &sigfigs, sizeof(sigfigs));
    write(1 /*stdout*/, &snaplen, sizeof(snaplen));
    write(1 /*stdout*/, &network, sizeof(network));
}

/**************************************************************************/
/*!
    Write the frame header into wireshark. This is required for the libpcap
    format and informs wireshark that a new frame is coming.
*/
/**************************************************************************/
static void write_frame_hdr(uint8_t len)
{
    uint32_t ts_sec;    /* timestamp seconds */
    uint32_t ts_usec;   /* timestamp microseconds */
    uint32_t incl_len;  /* number of octets of packet saved in file */
    uint32_t orig_len;  /* actual length of packet */
    struct timeval tv;

    gettimeofday(&tv, NULL);
    ts_sec      = tv.tv_sec;
    ts_usec     = tv.tv_usec;
    incl_len    = len;
    orig_len    = len;

    write(1 /*stdout*/, &ts_sec, sizeof(ts_sec));
    write(1 /*stdout*/, &ts_usec, sizeof(ts_usec));
    write(1 /*stdout*/, &incl_len, sizeof(incl_len));
    write(1 /*stdout*/, &orig_len, sizeof(orig_len));
}

/**************************************************************************/
/*!
    Write one frame into wireshark (via the pipe).
*/
/**************************************************************************/
static void write_frame(uint8_t frame_len)
{
    uint8_t i;

    // write header to inform WS that new frame has arrived
    write_frame_hdr(frame_len);
    write(1 /*stdout*/, packet, frame_len);
    fflush(stdout);
}


/**************************************************************************/
/*!
    Here's the meat of the code.
*/
/**************************************************************************/
int main(int argc, char *argv[])
{
	int len;

	write_global_pcap_hdr();
	while(1)
	{
		len = recv_packet();
		write_frame(len);
	}
}

