<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.ico" >
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>CC26xx Driver Library: Programming Model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ti_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr>
  <td style="padding-left: 0.5em;">
   <div id="projectname">CC26xx Driver Library
   </div>
  </td>
  <td id="projectlogo"><a href="http://www.ti.com"><img align="right" alt="Logo" src="ti_logo_header.png"/></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>CC26xx&#160;APIs</span></a></li>
      <li><a href="usergroup0.html"><span>Register&#160;Descriptions</span></a></li>
      <li><a href="usergroup1.html"><span>Online&#160;Resources</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('prog_model.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Programming Model </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#prog_model_intro">Introduction</a></li>
<li class="level1"><a href="#prog_model_direct">Direct Register Access Model</a></li>
<li class="level1"><a href="#prog_model_software">Software Driver Model</a></li>
<li class="level1"><a href="#prog_model_combine">Combining the Models</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="prog_model_intro"></a>
Introduction</h1>
<p>The peripheral driver library provides support for two programming models: The direct register access model and the software driver model. Each model can be used independently or combined, based on the needs of the application or the programming environment desired by the developer.</p>
<p>Each programming model has advantages and disadvantages. Use of the direct register access model generally results in smaller and more efficient code than using the software driver model. However, the direct register access model requires detailed knowledge of the operation of each register and bit field, as well as their interactions and any sequencing required for proper operation of the peripheral; the software driver model insulates the developer from these details, thus generally requiring less time to develop applications.</p>
<h1><a class="anchor" id="prog_model_direct"></a>
Direct Register Access Model</h1>
<p>In the direct register access model, the peripherals are programmed by the application by writing values directly into the registers in the peripheral. A set of defines, that simplify this process, is provided.</p>
<p>These defines are stored in the <code>inc/</code> directory and there is a single <code>hw_*.h</code> header file for each peripheral type. For example, the defines for SSI are stored in the <code>hw_ssi.h</code> header file.</p>
<p>The defines used by the direct register access model follow a naming convention that makes it easier to know how to use a particular macro. The rules are as follows:</p>
<ul>
<li>All register name macros start with the module name (for example, <code>SSI</code> for the SSI module) and are followed by the name of the register as it appears in the data sheet.</li>
<li>The register defines are offset values relative to the base address of a peripheral instance. If an offset is used, this will be identified in the register name using <code>_O_</code> (for example, <code>CR0</code> register in the data sheet results in <code>SSI_O_CR0</code>). The base address of each peripheral is defined in the memory map header file stored in the <code>inc/</code> directory, under the name <code>hw_memmap.h</code>.</li>
<li>All register defines for a given peripheral are listed in the first section of the corresponding header file (for example, in the first section of the <code>hw_ssi.h</code> file for the SSI registers).</li>
<li>All register bit fields start with the module name, followed by the register name, and then followed by the bit field name as it appears in the data sheet. For example, the <code>SCR</code> bit field in the <code>CR0</code> register in the <code>SSI</code> module is identified by <code>SSI_CR0_SCR...</code>.</li>
<li>Defines that end in <code>_M</code> represent the mask for a bit field in a register.</li>
<li>Defines that end in <code>_S</code> represent the number of bits to shift a value in order to align it with a bit field. These values match the macro with the same base name but ending with <code>_M</code>.</li>
<li>If a bit field has enumerated values the enumeration names are appended to the name of the bit field define. For example, the <code>SSI_CR0_DSS</code> bit field has a set of enumerations that specify the allowed values of this bit field pre-shifted to the correct bit positions. E.g. the enumeration "7_BIT" can be set using the define <code>SSI_CR0_DSS_7_BIT</code>. This improves readability and also helps the programmer select valid values for specific bit fields.</li>
</ul>
<p>Given these defines, the <code>CR0</code> register, in the first instance of the SSI peripheral (SSI0), can be programmed as follows:</p>
<pre class="fragment">    HWREG(SSI0_BASE + SSI_O_CR0) = ((5 &lt;&lt; SSI_CR0_SCR_S) | SSI_CR0_SPH | SSI_CR0_SPO);
</pre><p>Alternatively, the following has the same effect (although it is not as easy to understand):</p>
<pre class="fragment">    HWREG(SSI0_BASE + SSI_O_CR0) = 0x000005c0;
</pre><p>The value of the <code>SCR</code> field from the <code>CR0</code> register can be extracted as follows:</p>
<pre class="fragment">    ulValue = (HWREG(SSI0_BASE + SSI_O_CR0) &amp; SSI_CR0_SCR_M) &gt;&gt; SSI_CR0_SCR_S;
</pre><h1><a class="anchor" id="prog_model_software"></a>
Software Driver Model</h1>
<p>In the software driver model, the API provided by the peripheral driver library is used by applications to control the peripherals. Because these drivers provide complete control of the peripherals in their normal mode of operation, it is possible to write an entire application without direct access to the hardware. This method provides for rapid development of the application without requiring knowledge of how to program the peripheral registers.</p>
<p>Corresponding to the direct register access model example, the following call also programs the <code>CR0</code> register in the SSI module (though the register name is hidden by the API):</p>
<pre class="fragment">    SSIConfigSetExpClk(SSI0_BASE, 50000000, SSI_FRF_MOTO_MODE_3,
                       SSI_MODE_MASTER, 1000000, 8);
</pre><p>The resulting value in the <code>CR0</code> register might not be exactly the same because <a class="el" href="group__ssi__api.html#ga920b241b9d99f0b19f1c0a6f3779bc10" title="Configures the synchronous serial port. ">SSIConfigSetExpClk()</a> may compute a different value for the <code>SCR</code> bit field than what was used in the direct register access model example.</p>
<p>All example applications use the software driver model.</p>
<h1><a class="anchor" id="prog_model_combine"></a>
Combining the Models</h1>
<p>The direct register access model and software driver model can be used together in a single application, thus applying the most appropriate model as needed to any particular situation within the application. For example, the software driver model can be used to configure the peripherals (because this is not performance critical) and the direct register access model can be used to operate the peripheral (which may be more performance critical). Or, the software driver model can be used for peripherals that are not performance critical (such as a UART used for data logging) and the direct register access model can be used for performance critical peripherals (such as the ADC module used to capture real-time analog data). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Overview</a></li>
    <li class="footer">&copy Copyright 2015 Texas Instruments Incorporated. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
