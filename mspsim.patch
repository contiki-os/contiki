diff --git a/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XGui.java b/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XGui.java
new file mode 100644
index 0000000..40daa7c
--- /dev/null
+++ b/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XGui.java
@@ -0,0 +1,161 @@
+/**
+ * Copyright (c) 2012, Swedish Institute of Computer Science.
+ * Copyright (c) 2016, University of Bristol
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the Institute nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is part of MSPSim.
+ */
+
+package se.sics.mspsim.platform.z1x;
+import java.awt.Color;
+import java.awt.Graphics;
+import java.awt.Rectangle;
+import java.awt.event.MouseAdapter;
+import java.awt.event.MouseEvent;
+
+import se.sics.mspsim.core.StateChangeListener;
+import se.sics.mspsim.platform.AbstractNodeGUI;
+
+public class Z1XGui extends AbstractNodeGUI {
+
+    private static final long serialVersionUID = 7016480889484768582L;
+
+    private static final int GREEN_Y = 88;
+    private static final int BLUE_Y = 99;
+    private static final int RED_Y = 77;
+    private static final int LED_X = 184;
+    private static final int LED_WIDTH = 11;
+    private static final int LED_HEIGHT = 6;
+
+    private static final Color BLUE_TRANS = new Color(0x80, 0x80, 0xff, 0xa0);
+    private static final Color GREEN_TRANS = new Color(0x40, 0xf0, 0x40, 0xa0);
+    private static final Color RED_TRANS = new Color(0xf0, 0x40, 0x40, 0xa0);
+
+    private static final Color BLUE_C = new Color(0xffa0a0ff);
+    private static final Color GREEN_C = new Color(0xff60ff60);
+    private static final Color RED_C = new Color(0xffff8000);
+
+    private static final Color BUTTON_C = new Color(0x60ffffff);
+
+    private static final Rectangle LEDS_BOUNDS =
+      new Rectangle(LED_X - 2, RED_Y - 2, LED_WIDTH + 1, BLUE_Y - RED_Y + LED_HEIGHT + 1);
+
+    private boolean buttonDown = false;
+    private boolean resetDown = false;
+
+    private final Z1XNode node;
+    private final StateChangeListener ledsListener = new StateChangeListener() {
+        public void stateChanged(Object source, int oldState, int newState) {
+            repaint(LEDS_BOUNDS);
+        }
+    };
+
+    public Z1XGui(Z1XNode node) {
+        super("Z1XGui", "images/z1.jpg");
+        this.node = node;
+    }
+
+    protected void startGUI() {
+        MouseAdapter mouseHandler = new MouseAdapter() {
+
+            // For the button sensor and reset button on the Sky nodes.
+            public void mousePressed(MouseEvent e) {
+                int x = e.getX();
+                int y = e.getY();
+                if (x > 53 && x < 66) {
+                    if (y > 231 && y < 246) {
+                        buttonDown = true;
+                        Z1XGui.this.node.getButton().setPressed(true);
+                        repaint(53, 231, 14, 16);
+                    } else if (y > 260 && y < 273) {
+                        resetDown = true;
+                        repaint(53, 260, 14, 13);
+                    }
+                }
+            }
+
+            public void mouseReleased(MouseEvent e) {
+                if (buttonDown) {
+                    buttonDown = false;
+                    Z1XGui.this.node.getButton().setPressed(false);
+                    repaint(53, 231, 14, 16);
+
+                } else if (resetDown) {
+                    int x = e.getX();
+                    int y = e.getY();
+                    resetDown = false;
+                    if (x > 53 && x < 66 && y > 260 && y < 273) {
+                        Z1XGui.this.node.getCPU().reset();
+                    }
+                    repaint(53, 260, 14, 13);
+                }
+            }
+        };
+
+        this.addMouseListener(mouseHandler);
+        node.getLeds().addStateChangeListener(ledsListener);
+    }
+
+    protected void stopGUI() {
+        node.getLeds().removeStateChangeListener(ledsListener);
+    }
+
+    protected void paintComponent(Graphics g) {
+        Color old = g.getColor();
+
+        super.paintComponent(g);
+
+        // Display all active leds
+        if (node.redLed) {
+            g.setColor(RED_TRANS);
+            g.fillOval(LED_X - 2, RED_Y - 1, LED_WIDTH, LED_HEIGHT);
+            g.setColor(RED_C);
+            g.fillOval(LED_X, RED_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
+        }
+        if (node.greenLed) {
+            g.setColor(GREEN_TRANS);
+            g.fillOval(LED_X - 2, GREEN_Y - 1, LED_WIDTH, LED_HEIGHT);
+            g.setColor(GREEN_C);
+            g.fillOval(LED_X, GREEN_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
+        }
+        if (node.blueLed) {
+            g.setColor(BLUE_TRANS);
+            g.fillOval(LED_X - 2, BLUE_Y - 1, LED_WIDTH, LED_HEIGHT);
+            g.setColor(BLUE_C);
+            g.fillOval(LED_X, BLUE_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
+        }
+        if (buttonDown) {
+            g.setColor(BUTTON_C);
+            g.fillOval(55, 234, 9, 9);
+        }
+        if (resetDown) {
+            g.setColor(BUTTON_C);
+            g.fillOval(55, 262, 9, 9);
+        }
+        g.setColor(old);
+    }
+
+}
diff --git a/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XNode.java b/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XNode.java
new file mode 100644
index 0000000..3750fbf
--- /dev/null
+++ b/tools/mspsim/se/sics/mspsim/platform/z1x/Z1XNode.java
@@ -0,0 +1,185 @@
+package se.sics.mspsim.platform.z1x;
+
+import java.io.IOException;
+import se.sics.mspsim.chip.Button;
+import se.sics.mspsim.chip.CC2420;
+import se.sics.mspsim.chip.Leds;
+import se.sics.mspsim.chip.M25P80;
+import se.sics.mspsim.config.MSP430f5437Config;
+import se.sics.mspsim.core.EmulationException;
+import se.sics.mspsim.core.IOPort;
+import se.sics.mspsim.core.IOUnit;
+import se.sics.mspsim.core.PortListener;
+import se.sics.mspsim.core.USARTListener;
+import se.sics.mspsim.core.USARTSource;
+import se.sics.mspsim.core.USCI;
+import se.sics.mspsim.platform.GenericNode;
+import se.sics.mspsim.ui.SerialMon;
+import se.sics.mspsim.util.ArgumentManager;
+
+public class Z1XNode extends GenericNode implements PortListener, USARTListener {
+
+    public static final int MODE_LEDS_OFF = 0;
+    public static final int MODE_LEDS_1 = 1;
+    public static final int MODE_LEDS_2 = 2;
+    public static final int MODE_LEDS_3 = 3;
+    public static final int MODE_MAX = MODE_LEDS_3;
+
+    // Port 2.5 - Button
+    public static final int BUTTON_PIN = 5;
+
+    /* P1.2 - Input: FIFOP from CC2420 */
+    /* P1.3 - Input: FIFO from CC2420 */
+    /* P1.4 - Input: CCA from CC2420 */
+    public static final int CC2420_FIFOP = 2;
+    public static final int CC2420_FIFO = 3;
+    public static final int CC2420_CCA = 4;
+
+    /* P4.1 - Input: SFD from CC2420 */
+    /* P4.5 - Output: VREG_EN to CC2420 */
+    /* P3.0 - Output: SPI Chip Select (CS_N) */
+    public static final int CC2420_SFD = 1;
+    public static final int CC2420_VREG = (1 << 5);
+    public static final int CC2420_CHIP_SELECT = 0x01;
+
+    public static final int I2C_DATA_PIN = 1;
+    public static final int I2C_DATA = 1 << I2C_DATA_PIN;
+    public static final int I2C_CLK_PIN = 2;
+    public static final int I2C_CLK = 1 << I2C_CLK_PIN;
+
+    private IOPort port1;
+    private IOPort port2;
+    private IOPort port3;
+    private IOPort port4;
+    private IOPort port5;
+
+    public static final int LEDS_CONF_RED    = 0x10;
+    public static final int LEDS_CONF_GREEN  = 0x40;
+    public static final int LEDS_CONF_BLUE   = 0x20;
+    private static final int[] LEDS = { 0xff2020, 0x40ff40, 0x4040ff };
+
+    boolean redLed;
+    boolean blueLed;
+    boolean greenLed;
+
+    private Leds leds;
+    private Button button;
+    private Z1XGui gui;
+
+    private CC2420 radio;
+
+    public Z1XNode() {
+        super("Z1X", new MSP430f5437Config());
+        setMode(MODE_LEDS_OFF);
+    }
+
+    public Leds getLeds() {
+        return leds;
+    }
+
+    public Button getButton() {
+        return button;
+    }
+
+    public void dataReceived(USARTSource source, int data) {
+        // USCI s = (USCI) source;
+        radio.dataReceived(source, data);
+        /* if nothing selected, just write back a random byte to these devs */
+        if (!radio.getChipSelect()) {
+            source.byteReceived(0);
+        }
+    }
+
+    private int lastPort5 = 0;
+    public void portWrite(IOPort source, int data) {
+        switch (source.getPort()) {
+        case 3:
+            // Chip select = active low...
+            radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
+            break;
+        case 4:
+            radio.setVRegOn((data & CC2420_VREG) != 0);
+            break;
+        case 5: {
+            if ((data & (LEDS_CONF_RED|LEDS_CONF_BLUE|LEDS_CONF_GREEN)) !=
+                (lastPort5 & (LEDS_CONF_RED|LEDS_CONF_BLUE|LEDS_CONF_GREEN))) {
+                redLed = (data & LEDS_CONF_RED) == 0;
+                blueLed = (data & LEDS_CONF_BLUE) == 0;
+                greenLed = (data & LEDS_CONF_GREEN) == 0;
+                leds.setLeds((redLed ? 1 : 0) + (greenLed ? 2 : 0) + (blueLed ? 4 : 0));
+                int newMode = (redLed ? 1 : 0) + (greenLed ? 1 : 0) + (blueLed ? 1 : 0);
+                setMode(newMode);
+            }
+            lastPort5 = data;
+            break;
+        }
+        }
+    }
+
+    private void setupNodePorts() {
+        port1 = cpu.getIOUnit(IOPort.class, "P1");
+//        port1.addPortListener(this);
+        port2 = cpu.getIOUnit(IOPort.class, "P2");
+//        port2.addPortListener(this);
+        port3 = cpu.getIOUnit(IOPort.class, "P3");
+        port3.addPortListener(this);
+        port4 = cpu.getIOUnit(IOPort.class, "P4");
+        port4.addPortListener(this);
+        port5 = cpu.getIOUnit(IOPort.class, "P5");
+        port5.addPortListener(this);
+
+        IOUnit usart0 = cpu.getIOUnit("USCI B0");
+        if (usart0 instanceof USARTSource) {
+            radio = new CC2420(cpu);
+            radio.setCCAPort(port1, CC2420_CCA);
+            radio.setFIFOPPort(port1, CC2420_FIFOP);
+            radio.setFIFOPort(port1, CC2420_FIFO);
+
+            ((USARTSource) usart0).addUSARTListener(this);
+            radio.setSFDPort(port4, CC2420_SFD);
+        } else {
+            throw new EmulationException("Could not setup mote - missing USCI B0");
+        }
+
+        leds = new Leds(cpu, LEDS);
+        button = new Button("Button", cpu, port2, BUTTON_PIN, true);
+
+        IOUnit usart = cpu.getIOUnit("USCI A1");
+        if (usart instanceof USARTSource) {
+            registry.registerComponent("serialio", usart);
+        }
+    }
+
+    public void setupNode() {
+        setupNodePorts();
+
+        if (!config.getPropertyAsBoolean("nogui", true)) {
+            setupGUI();
+
+            // Add some windows for listening to serial output
+            IOUnit usart = cpu.getIOUnit("USCI A1");
+            if (usart instanceof USARTSource) {
+                SerialMon serial = new SerialMon((USARTSource)usart, "USCI A1 Port Output");
+                registry.registerComponent("serialgui", serial);
+            }
+        }
+    }
+
+    public void setupGUI() {
+        if (gui == null) {
+            gui = new Z1XGui(this);
+            registry.registerComponent("nodegui", gui);
+        }
+    }
+
+    public int getModeMax() {
+        return MODE_MAX;
+    }
+
+    public static void main(String[] args) throws IOException {
+        Z1XNode node = new Z1XNode();
+        ArgumentManager config = new ArgumentManager();
+        config.handleArguments(args);
+        node.setupArgs(config);
+    }
+}
