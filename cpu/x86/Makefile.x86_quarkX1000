# See mm/README.md for a description of available settings:
X86_CONF_PROT_DOMAINS ?= none

include $(CONTIKI)/cpu/x86/Makefile.x86_common

CONTIKI_CPU_DIRS += drivers/legacy_pc drivers/quarkX1000 init/legacy_pc net mm

CONTIKI_SOURCEFILES += bootstrap_quarkX1000.S rtc.c pit.c pic.c irq.c nmi.c pci.c uart-16x50.c uart.c gpio.c i2c.c eth.c shared-isr.c
CONTIKI_SOURCEFILES += imr.c msg-bus.c
CONTIKI_SOURCEFILES += stacks.c

ifneq ($(X86_CONF_PROT_DOMAINS),none)
CONTIKI_SOURCEFILES += prot-domains.c $(X86_CONF_PROT_DOMAINS)-prot-domains.c imr-conf.c

ifeq ($(X86_CONF_PROT_DOMAINS),paging)
LINKERSCRIPT_SFX = _paging
X86_CONF_SYSCALLS_INT = 1
ifeq ($(X86_CONF_USE_INVLPG),1)
CFLAGS += -DX86_CONF_USE_INVLPG
endif
# This matches the definition of X86_CONF_PROT_DOMAINS__PAGING in prot-domains.h:
CFLAGS += -DX86_CONF_PROT_DOMAINS=1
else ifeq ($(X86_CONF_PROT_DOMAINS),tss)
# This matches the definition of X86_CONF_PROT_DOMAINS__TSS in prot-domains.h:
CFLAGS += -DX86_CONF_PROT_DOMAINS=2
X86_CONF_MULTI_SEG = 1
CONTIKI_SOURCEFILES += tss-prot-domains-asm.S
else ifeq ($(X86_CONF_PROT_DOMAINS),swseg)
# This matches the definition of X86_CONF_PROT_DOMAINS__SWSEG in prot-domains.h:
CFLAGS += -DX86_CONF_PROT_DOMAINS=3
X86_CONF_SYSCALLS_INT = 1
X86_CONF_MULTI_SEG = 1
else
$(error Unrecognized setting for X86_CONF_PROT_DOMAINS: \
        $(X86_CONF_PROT_DOMAINS).  See cpu/x86/mm/README.md for \
        descriptions of available settings)
endif

ifeq ($(X86_CONF_SYSCALLS_INT),1)
CONTIKI_SOURCEFILES += syscalls-int-asm.S tss.c
endif

ifeq ($(X86_CONF_MULTI_SEG),1)
LINKERSCRIPT_SFX = _multi_seg
CONTIKI_SOURCEFILES += multi-segment.c
# Due to the way the multi-segment implementation of protection domains define
# tightly-bounded stack segments, the base pointer register cannot be used as
# a general-purpose register in all circumstances.  The stack segment is used
# by default for a data access that uses the base pointer as the base register
# to compute the address.  If the data referenced by the base pointer is not
# on the stack, then the access will fail.  Thus, it is necessary to disable
# the omit-frame-pointer optimization.  See mm/README.md for more details of
# how multi-segment protection domains are implemented.
CFLAGS += -fno-omit-frame-pointer
endif

endif

CFLAGS += -m32 -march=i586 -mtune=i586
LDFLAGS += -m32 -Xlinker -T -Xlinker $(CONTIKI)/cpu/x86/quarkX1000$(LINKERSCRIPT_SFX).ld
# The C compiler is used to invoke the assembler, so the CFLAGS should be
# passed to it on the command line:
ASFLAGS = -c $(CFLAGS)

ifeq ($(X86_CONF_RESTRICT_DMA),1)
CONTIKI_SOURCEFILES += imr-conf.c
CFLAGS += -DX86_CONF_RESTRICT_DMA
LDFLAGS += -Xlinker -T -Xlinker $(CONTIKI)/cpu/x86/quarkX1000_dma.ld
endif

### UEFI support

UEFI_DIR = $(CONTIKI_CPU)/uefi

ifndef EN_UEFI
# Include a Makefile generated by the build_uefi.sh script, if available.
# If that script was not run, then UEFI support will not be built.
-include $(UEFI_DIR)/Makefile.uefi
endif

ifeq ($(EN_UEFI),1)
	EDK2_DIR = $(UEFI_DIR)/edk2

	GEN_FW = $(EDK2_DIR)/BaseTools/Source/C/bin/GenFw

	CONTIKI_CPU_DIRS += uefi
	CONTIKI_SOURCEFILES += bootstrap_uefi.c
	CFLAGS += -I$(EDK2_DIR)/MdePkg/Include -I$(EDK2_DIR)/MdePkg/Include/Ia32
else
    $(info Note: UEFI support is disabled.)
    $(info To enable UEFI support, run $(CONTIKI_CPU)/uefi/build_uefi.sh prior)
    $(info to building Contiki.)
endif
