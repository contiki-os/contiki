/* Base node code for CC2538 version microcontroller * This version is designed to work with the MangoES and should be placed inside the ES * Use a USB to USART converter and feed the basenode board with 3.3V. * The USB adapter should be connected to the 4 pin PA header (3.3v, RX, TX, GND) * Uses the mesh networking functunality of the RIME stack * Uses ContikiMAC for radio duty cycling *///Included files#include <stdio.h>#include <string.h>#include <stdlib.h>#include <ctype.h>#include "contiki.h"#include "contiki-lib.h"#include "contiki-net.h"#include "net/ip/uip.h"#include "net/rpl/rpl.h"#include "net/netstack.h"#include "dev/leds.h"#include "dev/uart.h"#include "net/ipv6/sicslowpan.h"#define false 0#define true 1#define MESSAGE "Hello"#define DEBUG DEBUG_PRINT#include "net/ip/uip-debug.h"#define UIP_IP_BUF   ((struct uip_ip_hdr *)&uip_buf[UIP_LLH_LEN])#define UDP_CLIENT_PORT	8765#define UDP_SERVER_PORT	5678#define UDP_EXAMPLE_ID  190//Global Variableschar usart_rx_buffer[300];											//Define a buffer for storing serial port stringsint usart_rx_buffer_index = 0;										//And an index for that bufferchar SendData;unsigned char channel = 0x19;										//Set the RF channel to 0x19 by default	static struct uip_udp_conn *server_conn;/*---------------------------- Contiki Processes ----------------------------*/PROCESS(example_mesh_process, "BaseNode Mesh");PROCESS(serial_process, "Serial Process");AUTOSTART_PROCESSES(&example_mesh_process,&serial_process);int indexOf_shift (char* base, char* str, int startIndex) {    int result;    int baselen = strlen(base);    // str should not longer than base    if (strlen(str) > baselen || startIndex > baselen) {        result = -1;    } else {        if (startIndex < 0 ) {            startIndex = 0;        }        char* pos = strstr(base+startIndex, str);        if (pos == NULL) {            result = -1;        } else {            result = pos - base;        }    }    return result;}int indexOf (char* base, char* str) {    return indexOf_shift(base, str, 0);}static void print_route(void){	rpl_dag_t *dag;	uip_ds6_route_t *r;	dag = rpl_get_any_dag();	if(dag->preferred_parent != NULL) {	// Display the address of the parent node		PRINT6ADDR(rpl_get_parent_ipaddr(dag->preferred_parent));		PRINTF("\r");	}	for(r = uip_ds6_route_head(); r != NULL; r = uip_ds6_route_next(r)) {		// Display the addresses of the nodes for which we are the parent		PRINT6ADDR(&r->ipaddr);		PRINTF("\r");	}	PRINTF("---\r");}static void print_nbrs(void){	uint8_t i, any;    uip_ds6_nbr_t *nbr;		PRINTF("\r#Addresses [%u max]\r", UIP_DS6_ADDR_NB);    for (i = 0; i < UIP_DS6_ADDR_NB; i++) {		if (uip_ds6_if.addr_list[i].isused) {			PRINTF("!");			uip_debug_ipaddr_print(&uip_ds6_if.addr_list[i].ipaddr);			PRINTF("\r");			}		}		PRINTF("\r!Neighbors [%u max]\r",NBR_TABLE_MAX_NEIGHBORS);		any = 0;		for(nbr = nbr_table_head(ds6_neighbors);			nbr != NULL;        nbr = nbr_table_next(ds6_neighbors, nbr)) {        PRINTF("!");        uip_debug_ipaddr_print(&nbr->ipaddr);        if (nbr->isrouter) 			PRINTA(" router");        switch (nbr->state) {          case NBR_INCOMPLETE:            PRINTF(" INCOMPLETE");            break;          case NBR_REACHABLE:            PRINTF(" REACHABLE");            break;          case NBR_STALE:            PRINTF(" STALE");            break;          case NBR_DELAY:            PRINTF(" DELAY");            break;          case NBR_PROBE:            PRINTF(" PROBE");            break;        }        PRINTF("\r");        any = 1;      }      if (!any) PRINTF("!<none>\r");      PRINTF("\r!Routes [%u max]\r",UIP_DS6_ROUTE_NB);      uip_ds6_route_t *r;      any = 0;      for(r = uip_ds6_route_head(); r != NULL; r = uip_ds6_route_next(r)) {        PRINTF("!");        uip_debug_ipaddr_print(&r->ipaddr);        PRINTF("/%u (via ", r->length);        uip_debug_ipaddr_print(uip_ds6_route_nexthop(r));        PRINTF(") %lus\r", r->state.lifetime);        any = 1;      }      if (!any) 		  PRINTF("!<none>\r");      PRINTF("\r@\r");    }/************************ SERIAL PORT HANDLING *******************************//*****************************************************************************//* This function processes lines received from the serial port. These are    *//* commands from the ATMega microcontroller for setting the channel and      *//* getting configuration data from the cc2530.								 */static void process_line(void){	uint8_t addrToSend1, addrToSend2, addrToSend3, addrToSend4;	uip_ip6addr_t sendTo;  static int seq_id;	char NodeAddress[12];		if (strncmp(usart_rx_buffer,"?",1) == 0)	{//		printf("@A=%d\r", channel);//		printf("@S=%u.%u\r",linkaddr_node_addr.u8[0], 	linkaddr_node_addr.u8[1]);		//print_route();		print_nbrs();	}	if (strncmp(usart_rx_buffer,"~",1) == 0)	{		printf("RESET NODE\r");		while(1){};	}	else if (strncmp(usart_rx_buffer,"SO",1) == 0)    {		//printf("\rMessage for a node from MANGO\r");        //printf(usart_rx_buffer);   		packetbuf_copyfrom(usart_rx_buffer, 110);   		//trickle_send(&trickle);	}	else if (strncmp(usart_rx_buffer,"GA",1) == 0)    {		//printf("\rMessage for a node from MANGO\r");        //printf(usart_rx_buffer);   		packetbuf_copyfrom(usart_rx_buffer, 110);		//printf("Sending:");		printf(usart_rx_buffer);		printf("\r");        strncpy(NodeAddress, usart_rx_buffer + 2, 2);		addrToSend1 = strtol(NodeAddress, NULL, 16);   		strncpy(NodeAddress, usart_rx_buffer + 5, 2);		addrToSend2 = strtol(NodeAddress, NULL, 16);				strncpy(NodeAddress, usart_rx_buffer + 8, 2);		addrToSend3 = strtol(NodeAddress, NULL, 16);   		strncpy(NodeAddress, usart_rx_buffer + 11, 2);		addrToSend4 = strtol(NodeAddress, NULL, 16);			printf("SendTo %02x:%02x:%02x:%02x\r", addrToSend1, addrToSend2, addrToSend3, addrToSend4);    uip_ip6addr_u8(&sendTo, 170, 170, 0, 0, 0, 0, 0, 0, 2, 18, 75, 0, addrToSend1, addrToSend2, addrToSend3, addrToSend4);	    PRINTF("Sending GA command\r");    uip_ipaddr_copy(&server_conn->ripaddr, &sendTo);	//uip_ipaddr_copy(&server_conn->ripaddr, &UIP_IP_BUF->srcipaddr);	//printf("%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d\r", server_conn->ripaddr.u8[0], server_conn->ripaddr.u8[1], server_conn->ripaddr.u8[2], server_conn->ripaddr.u8[3], server_conn->ripaddr.u8[4], server_conn->ripaddr.u8[5], server_conn->ripaddr.u8[6], server_conn->ripaddr.u8[7], server_conn->ripaddr.u8[8], server_conn->ripaddr.u8[9], server_conn->ripaddr.u8[10], server_conn->ripaddr.u8[11], server_conn->ripaddr.u8[12], server_conn->ripaddr.u8[13], server_conn->ripaddr.u8[14], server_conn->ripaddr.u8[15]);    uip_udp_packet_send(server_conn, usart_rx_buffer, sizeof(usart_rx_buffer));    uip_create_unspecified(&server_conn->ripaddr);   			}
	else if (strncmp(usart_rx_buffer,"NW",1) == 0)
    {
		//printf("\rMessage for a node from MANGO\r");
        //printf(usart_rx_buffer);
   		packetbuf_copyfrom(usart_rx_buffer, 110);
		//printf("Sending:");
		printf(usart_rx_buffer);
		printf("\r");
        strncpy(NodeAddress, usart_rx_buffer + 2, 2);
		addrToSend1 = strtol(NodeAddress, NULL, 16);
   		strncpy(NodeAddress, usart_rx_buffer + 5, 2);
		addrToSend2 = strtol(NodeAddress, NULL, 16);		
		strncpy(NodeAddress, usart_rx_buffer + 8, 2);
		addrToSend3 = strtol(NodeAddress, NULL, 16);
   		strncpy(NodeAddress, usart_rx_buffer + 11, 2);
		addrToSend4 = strtol(NodeAddress, NULL, 16);	

		printf("SendTo %02x:%02x:%02x:%02x\r", addrToSend1, addrToSend2, addrToSend3, addrToSend4);
    uip_ip6addr_u8(&sendTo, 170, 170, 0, 0, 0, 0, 0, 0, 2, 18, 75, 0, addrToSend1, addrToSend2, addrToSend3, addrToSend4);

	
    PRINTF("Sending NW command\r");
    uip_ipaddr_copy(&server_conn->ripaddr, &sendTo);
	//uip_ipaddr_copy(&server_conn->ripaddr, &UIP_IP_BUF->srcipaddr);
	//printf("%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d.%03d\r", server_conn->ripaddr.u8[0], server_conn->ripaddr.u8[1], server_conn->ripaddr.u8[2], server_conn->ripaddr.u8[3], server_conn->ripaddr.u8[4], server_conn->ripaddr.u8[5], server_conn->ripaddr.u8[6], server_conn->ripaddr.u8[7], server_conn->ripaddr.u8[8], server_conn->ripaddr.u8[9], server_conn->ripaddr.u8[10], server_conn->ripaddr.u8[11], server_conn->ripaddr.u8[12], server_conn->ripaddr.u8[13], server_conn->ripaddr.u8[14], server_conn->ripaddr.u8[15]);
    uip_udp_packet_send(server_conn, usart_rx_buffer, sizeof(usart_rx_buffer));
    uip_create_unspecified(&server_conn->ripaddr);
   		
	}	else if (strncmp(usart_rx_buffer,"BA",1) == 0)    {		//printf("\rMessage for base station from MANGO\r");        printf(usart_rx_buffer);   		channel = (usart_rx_buffer[9] - 48) * 10;		channel += (usart_rx_buffer[10] - 48);		//	NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, channel);		printf("BA0.1CH=%d\r",channel);	}//	else if (strncmp(usart_rx_buffer,"a",1) == 0)//	{//		channel = (usart_rx_buffer[1] - 48) * 10;//		channel += (usart_rx_buffer[2] - 48);//		NETSTACK_RADIO.set_value(RADIO_PARAM_CHANNEL, channel);//		printf("On channel %d\r",channel);//	}		usart_rx_buffer_index = 0;}/*---------------------------------------------------------------------------*//* Serial port receive callback. This is called when the serial port receives*//* a character. It continues to read data from the serial port until either  *//* the string buffer is full or a carriage return is found. When a carriage  *//* return is found, the process_line() function is called to process the     *//* string.                                                                   */int uart_rx_callback(unsigned char c){	if (c == 0 || c > 127)	{		usart_rx_buffer_index = 0;		return 0;	}		if(usart_rx_buffer_index < 499)	{	 	usart_rx_buffer[usart_rx_buffer_index++] = c;		usart_rx_buffer[usart_rx_buffer_index] = '\0';	}	if(c == '\r')		process_line();		return 1;}/*static void recv(struct mesh_conn *c, const linkaddr_t *from, uint8_t hops){  char StringBuffer[200];				//Buffer for building the string of readings rx by the wireless network  char NodeAddress[3];  int comma1;  int packetLength;  unsigned int ctr;  packetbuf_copyto(StringBuffer);  StringBuffer[packetbuf_datalen()] = 0;  packetLength = packetbuf_datalen();     if (packetLength > 150)	  packetLength = 150;    strncpy(NodeAddress, StringBuffer, 2);  NodeAddress[2] = 0;    comma1 = indexOf(StringBuffer,",");  for (ctr = comma1; ctr < packetLength-1; ctr++) {	if(StringBuffer[ctr] == ',') {		printf("\r");						//Print the nodes address		printf(NodeAddress);		printf("%03d.%03d",from->u8[0], from->u8[1]);	}	else {		printf("%c",StringBuffer[ctr]);		//followed by the data (everything not a comma is data)	}  }  printf("\r");    printf(NodeAddress);  printf("%03d.%03d",from->u8[0], from->u8[1]);  printf("HOPS=%d\r", hops);  printf(NodeAddress);  printf("%03d.%03d",from->u8[0], from->u8[1]);  printf("RSSI=%d\r" , (int8_t)packetbuf_attr(PACKETBUF_ATTR_RSSI));    //printf("\rSTATS: 'from:%d.%d, hops:%d, rssi:%d'\r", originator->u8[0], originator->u8[1], hops, (int8_t)packetbuf_attr(PACKETBUF_ATTR_RSSI));}*//*---------------------------------------------------------------------------*/static voidtcpip_handler(void){  char *appdata;  unsigned int ctr;  int comma1;  int packetLength;  char NodeAddress[3];    if(uip_newdata()) {    appdata = (char *)uip_appdata;    appdata[uip_datalen()] = 0;   // PRINTF("DATA recv '%s' from ", appdata);   // PRINTF("%d", UIP_IP_BUF->srcipaddr.u8[sizeof(UIP_IP_BUF->srcipaddr.u8) - 1]);	//printf("RSSI=%d\r" , (int8_t)packetbuf_attr(PACKETBUF_ATTR_RSSI));    //PRINTF("\r");		  packetLength = strlen(appdata);    if (appdata[0] == '!')					//If packet begins with '!' it is routing information  {	printf(appdata);    }  else  {	strncpy(NodeAddress, appdata, 2);	NodeAddress[2] = 0;  	comma1 = indexOf(appdata,",");	for (ctr = comma1; ctr < packetLength-1; ctr++) {		if(appdata[ctr] == ',') {			printf("\r");						//Print the nodes address			printf(NodeAddress);			printf("%02x:%02x:%02x:%02x", UIP_IP_BUF->srcipaddr.u8[12], UIP_IP_BUF->srcipaddr.u8[13],UIP_IP_BUF->srcipaddr.u8[14], UIP_IP_BUF->srcipaddr.u8[15]);		}		else {			printf("%c",appdata[ctr]);		//followed by the data (everything not a comma is data)		}	}	printf("\r");  	printf(NodeAddress);	printf("%02x:%02x:%02x:%02x", UIP_IP_BUF->srcipaddr.u8[12], UIP_IP_BUF->srcipaddr.u8[13],UIP_IP_BUF->srcipaddr.u8[14], UIP_IP_BUF->srcipaddr.u8[15]);	printf("HOPS=%d\r", uip_ds6_if.cur_hop_limit - UIP_IP_BUF->ttl + 1);	printf(NodeAddress);	printf("%02x:%02x:%02x:%02x", UIP_IP_BUF->srcipaddr.u8[12], UIP_IP_BUF->srcipaddr.u8[13],UIP_IP_BUF->srcipaddr.u8[14], UIP_IP_BUF->srcipaddr.u8[15]);	//printf("RSSI=%d\r" , (int8_t)packetbuf_attr(PACKETBUF_ATTR_RSSI));	printf("RSSI=%d\r" , sicslowpan_get_last_rssi());	  }	#if SERVER_REPLY    PRINTF("DATA sending reply\r");    uip_ipaddr_copy(&server_conn->ripaddr, &UIP_IP_BUF->srcipaddr);    uip_udp_packet_send(server_conn, "Reply", sizeof("Reply"));    uip_create_unspecified(&server_conn->ripaddr);#endif  }}/*---------------------------------------------------------------------------*/static voidprint_local_addresses(void){  int i;  uint8_t state;  PRINTF("Server IPv6 addresses: ");  for(i = 0; i < UIP_DS6_ADDR_NB; i++) {    state = uip_ds6_if.addr_list[i].state;    if(state == ADDR_TENTATIVE || state == ADDR_PREFERRED) {      PRINT6ADDR(&uip_ds6_if.addr_list[i].ipaddr);      PRINTF("\r");      /* hack to make address "final" */      if (state == ADDR_TENTATIVE) {	uip_ds6_if.addr_list[i].state = ADDR_PREFERRED;      }    }  }}/*---------------------------------------------------------------------------*/PROCESS_THREAD(example_mesh_process, ev, data){  uip_ipaddr_t ipaddr;  struct uip_ds6_addr *root_if;    PROCESS_BEGIN();		PRINTF("UDP server started\r");#if UIP_CONF_ROUTER/* The choice of server address determines its 6LoPAN header compression. * Obviously the choice made here must also be selected in udp-client.c. * * For correct Wireshark decoding using a sniffer, add the /64 prefix to the 6LowPAN protocol preferences, * e.g. set Context 0 to aaaa::.  At present Wireshark copies Context/128 and then overwrites it. * (Setting Context 0 to aaaa::1111:2222:3333:4444 will report a 16 bit compressed address of aaaa::1111:22ff:fe33:xxxx) * Note Wireshark's IPCMV6 checksum verification depends on the correct uncompressed addresses. */ #if 0/* Mode 1 - 64 bits inline */   uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 1);#elif 1/* Mode 2 - 16 bits inline */  uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0x00ff, 0xfe00, 1);#else/* Mode 3 - derived from link local (MAC) address */  uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);  uip_ds6_set_addr_iid(&ipaddr, &uip_lladdr);#endif  uip_ds6_addr_add(&ipaddr, 0, ADDR_MANUAL);  root_if = uip_ds6_addr_lookup(&ipaddr);  if(root_if != NULL) {    rpl_dag_t *dag;    dag = rpl_set_root(RPL_DEFAULT_INSTANCE,(uip_ip6addr_t *)&ipaddr);    uip_ip6addr(&ipaddr, 0xaaaa, 0, 0, 0, 0, 0, 0, 0);    rpl_set_prefix(dag, &ipaddr, 64);    PRINTF("created a new RPL dag\r");  } else {    PRINTF("failed to create a new RPL DAG\r");  }#endif /* UIP_CONF_ROUTER */    print_local_addresses();  /* The data sink runs with a 100% duty cycle in order to ensure high      packet reception rates. */ // NETSTACK_MAC.off(1);  server_conn = udp_new(NULL, UIP_HTONS(UDP_CLIENT_PORT), NULL);  if(server_conn == NULL) {    PRINTF("No UDP connection available, exiting the process!\r");    PROCESS_EXIT();  }  udp_bind(server_conn, UIP_HTONS(UDP_SERVER_PORT));  PRINTF("Created a server connection with remote address ");  PRINT6ADDR(&server_conn->ripaddr);  PRINTF(" local/remote port %u/%u\r", UIP_HTONS(server_conn->lport), UIP_HTONS(server_conn->rport));  //Enable high gain mode on cc2592GPIO_SET_OUTPUT(GPIO_PORT_TO_BASE(GPIO_D_NUM), GPIO_PIN_MASK(2));			GPIO_SET_PIN(GPIO_PORT_TO_BASE(GPIO_D_NUM), GPIO_PIN_MASK(2));	  while(1) {    PROCESS_YIELD();    if(ev == tcpip_event) {      tcpip_handler();    } 		//else if (ev == sensors_event && data == &button_sensor) {//      PRINTF("Initiaing global repair\r");//      rpl_repair_root(RPL_DEFAULT_INSTANCE);//    }  }  PROCESS_END();}PROCESS_THREAD(serial_process, ev, data){	PROCESS_BEGIN();  //Set up the UART for communication with the MangoES	printf("\rUART BEGIN\r");	uart_set_input(0,uart_rx_callback);		while(1) {		PROCESS_YIELD();	}	PROCESS_END();}